---
date: 2022-11-20T08:30:05.000Z
layout: post
title: "[JavaScript] variable"
subtitle: What is a variable??
description: Let's find out what variables are and why we need them
image: http://cdn.shopify.com/s/files/1/1903/3233/articles/variable-free-fonts_grande.png
optimized_image: http://cdn.shopify.com/s/files/1/1903/3233/articles/variable-free-fonts_grande.png
category: JAVASCRIPT
tags:
  - JS
  - CS
  - Code
author: yoony
---

## What is a variable?

**변수는** 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**



> 변수는 하나의 값을 저장하기 위한 매커니즘으로 여러개의 값을 저장하려면 여러개의 변수를 사용해야한다. 단, 배열이나 객체 같은 자료구조를 사용하면 여러개의 값을 그룹화하여 하나의 값처럼 사용할 수 있다.

```js
//변수는 하나의 값을 저장하기 위한 수단
var name1 = value1
let name2 = value2
const name3 = value3

//객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화하여 사용 가능
var user = {id: 1, name: 'Cho', age: '28'}

var users = [
  {id: 1, name: 'Cho', age: '28'},
  {id: 1, name: 'Yoony', age: '28'}
]
```



## Why should we use variables?

변수를 사용해야하는 이유를 찾기 위해서는 **메모리의 구조**와 **동작 원리**를 알아야 한다.



### Memory?

``` 
메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다.

셀 하나의 크기는 '1바이트'이며 컴퓨터는 1바이트 단위로 데이터를 저장 또는 읽어 들인다.
각 셀은 고유의 메모리 주소를 갖는데 주소는 0부터 메모리 크기까지의 정수로 표시된다.

데이터를 사용, 재사용하기 위해서는 메모리에 접근하여 값을 가져와야 하는데,
이때 메모리 주소를 통해 직접 전급하는 것은 치명적인 오류를 발생시킬 가능성이 있다.

이를 해결하기 위해 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 
값을 재사용하기 위해 변수를 이용해 메모리 공간을 식별하기 위한 이름을 주게 된다.

변수는 컴파일러 또는 인터프리터에 의해 메모리 공간의 주소로 치환되어 실행이 된다.
```



## Variable declaration

변수를 사용하기 위해서는 두가지 필수 단계가 있다.
>1. 선언 단계 (declaration)
>2. 초기화 단계 (initialization)

**변수 선언**은 **변수를 생성하는 것**을 말하고 **초기화**는 JavaScript의 특징 중 하나로 **선언된 변수에 최초의 값 (undefined)을 할당해주는 것**을 말한다.



## Declaration keyword

변수를 선언할 때는 var, let, const라는 키워드를 사용해야한다.
ES6에서 let, const가 도입되기 전에는 var로 만 변수 선언이 가능했다.
var, let, const 이 3개의 키워드는 각각 차이점이 있다.

```
var
 - 중복 선언과 값의 재할당이 가능함.
 - 함수 레벨 스코프를 지원하여 의도치 않게 전역 변수 선언이 된다.

let
 - 중복 선언은 불가능하지만, 값의 재할당이 가능하다.

const
 - 중복 선언, 값의 재할당 모두 불가능 하다.
```

이러한 이유로 const는 값이 변하지 않는 상수를 선언할 때 사용되고 var와 let은 변하는 값을 선언할 때 사용한다.

> 예를 들면 for문 같은 반복문을 작성하는 경우 값이 계속 변하게 되는 ' i '라는 변수를 선언할 때 const가 아닌 var와 let (ES6에서는 let)을 사용하는 이유가 그렇다.
ES6가 도입되면서 var의 사용은 줄이고 let, const의 사용을 늘리고 있는데 그렇다고 해서 var를 사용하지 못하는 것은 아니다.
**ES6는 기본적으로 하위 호환성을 유지하며 ES5의 기반 위에 새로운 기능을 추가한 것이다.**



## Hoisting

JavaScript는 인터프리터에 의해서 한 줄씩 순차적으로 코드가 실행되는 **런타임 형식**이다. 
그런데 ***변수, 함수, 클래스*** 등 선언을 하는 모든 식별자는 **Hoisting(호이스팅)**이 된다.
호이스팅이란 JavaScript의 고유한 특징 중 하나로 **선언문**을 모두 **코드 최상단으로 끌어 올려진 것처럼 동작하게 한다**.

```js
//호이스팅에 따른 결과
console.log(name); // undefined
const name; // 변수 선언문
```

위 코드를 동작하면 변수 선언 전에 변수 참조가 발생하며 참조 에러(ReferenceError)가 발생 할 것으로 예상되지만 
실제로는 **호이스팅에 의해 변수 선언이 런타임 이전에 동작하게 되어 undefined라는 초기화된 변수 값을 잘 참조**하는걸 알 수 있다.

### Assignment

변수 선언후 또는 동시에 변수의 값을 할당 할 수 있다.
그런데 변수 선언과 동시에 변수의 값을 할당한다고 해도 실행 시점이 다르다.

```js
console.log(name); // undefined
const name = 'value'; //변수 선언과 값의 할당
consol.log(name); / value
```

위 코드를 보면 호이스팅에 의해 변수 선언 위에서 변수 참조가 이루어져도 에러가 발생하지 않는다.
다만, 값의 할당은 런타임 이후 순차적으로 실행이 되기 때문에 undefined라는 초기화된 값을 받아온다. 
런타임에 의해 순차적으로 변수 선언 이후 변수 참조를 하게 되면 할당된 값을 참조하는 것을 알 수 있다.
이런 값은 재할당도 가능한데 상수역할을 하는 const는 재할당이 불가능하다.
재할당의 특징은 원래 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 다시 값을 넣어 재할당 하는 것이 아니라 
새로운 메모리 공간을 확보하고 재할당 되는 값을 저장하므로써 실행된다.
이때 불필요한 값들이 메모리에 쌓이게 되는데 이것을 가비지 콜렉터라고 하는 기능이 불표요한 값들을 주기적으로 검사하여 해제하게 된다.

##### Garbage Collector

```
가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해 
더 이상 사용하지 않는 메모리를 해제하여 Memory leak(메모리 누수)을 방지한다.
다만, 해제의 실행 주기는 예측할 수 없다.
```











